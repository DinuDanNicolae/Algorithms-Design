# Algorithms-Design_1

Dinu Dan Nicolae
323CC

Ferry Problem:
The implementation of this problem is based on the Divide and Conquer principle using Binary Search. Initially, I calculate an upper and a lower limit for applying the binary search algorithm. The upper limit is represented by the sum of the weights of all cars, precisely if a single ferry were to transport all the cars. The lower limit is represented by the heaviest car, precisely if we had a ferry for each car. With these two limits, I apply the binary search algorithm to find the desired cost. Also, for each cost in this interval, I check the number of ferries required. If this number is less than the number of available ferries, I can look for a lower cost, as the ferries are not being used optimally. Thus, I can reapply the binary search algorithm with changed limits until they become equal and I find the desired cost. The complexity of the algorithm is O(log(n)).

Nostory Problem:
The implementation of this problem is based on a Greedy algorithm. For the first part, I put all the elements of the two lists in a vector that I sorted in descending order. In the end, I traversed the vector up to the list.length and summed the elements, thus finding the maximum score with an unlimited number of moves. The complexity of the algorithm is O(nlog(n)), where n is the length of the vector v in which I put all the elements of the lists. For the second part, I compared the elements "in the same positions" of the two lists and chose the maximum between them. This maximum was recorded in a frequency vector. Later, I introduced both lists into a single vector that I sorted. However, I saved the indices in a separate vector. Thus, I traversed the sorted vector starting with the largest elements and checked if at the index saved in the index vector was saved with 1 in the frequency vector. If affirmative, the element was added to the score, otherwise a move was made. The complexity of the algorithm is O(nlog(n)).

Sushi Problem:
The implementation of this problem is based on a dynamic programming algorithm, specifically the knapsack problem described in the laboratory. I created a vector of "sushi platters" where each platter has a totalGrade, representing the total sum of grades. Then, using the principles of dynamic programming, a matrix is built that represents a combination of sushi platters and sums of money. Then, the matrix is filled efficiently to determine which combination of platters offers the highest score. The complexity of the algorithm is O(a*b) where a is the number of platters and b is the total sum of grades.

Signal Problem:
The implementation of this problem is based on a dynamic programming counting algorithm. The idea of solving the first part consists of creating a matrix, with x rows and y columns, to calculate combinations of n taken by k with Pascal's triangle. The element on row i and column j is composed of the sum of the elements on row i and column j-1 and i-1, j in the matrix. In the end, at position x, y in the matrix is the number of combinations for type 1 signal where we cannot have 2 or more than 1 consecutive. The complexity of the algorithm is O(x^2).

For solving sub-item 2, I created a counting matrix where the element on row i and column j represents the number of combinations of type 2 signals where we cannot have 2 or more than 2 consecutive. The matrix was filled as follows: for the first 3 columns, I used the formula from sub-item 1, to create combinations with 0, 1, or 2 bits of 1. Subsequently, to create combinations where we must not have 3 or more consecutive bits of 1, I composed the number at position i,j as the sum of the elements on line i-1 and positions j, j-1, j-2. The complexity of the algorithm is O(x*y).

Badgpt Problem:
To solve this problem, I went through the string of characters and looked for one of the letters "n" or "u". Upon finding such a letter, I restarted the iteration from that point to find the number of occurrences after this letter. The number found was then parsed from a sequence of char into a long type number. This number + 1 was then sent as an argument to a fibonacci calculation function. The number of possible strings in the case of appearances of the letters "n" or "m" is equal to the (n + 1)th fibonacci number, n being the number of occurrences of a letter "n" or "m". In the case where we have an x number of appearances for "n" and a y number of appearances for "m", the number of
